w = mvad$weight[cond])
}
mvad$test <- factor(mvad$test, levels = 0:1, labels = c("non-test",
"test"))
tb <- xtabs(weight ~ test + pam4, data = mvad)
tb
data(mvad)
??mvad
library(TraMineR)
?mvad
mvad.alphabet <- c("employment", "FE", "HE", "joblessness", "school",
"training")
mvad.labels <- c("Employment", "Further Education", "Higher Education",
"Joblessness", "School", "Training")
mvad.scodes <- c("EM", "FE", "HE", "JL", "SC", "TR")
mvadseq <- seqdef(mvad[, 17:86], alphabet = mvad.alphabet,
states = mvad.scodes, labels = mvad.labels,weights=mvad$weight,xstep=6)
data(mvad)
mvadseq <- seqdef(mvad[, 17:86], alphabet = mvad.alphabet,
states = mvad.scodes, labels = mvad.labels,weights=mvad$weight,xstep=6)
subm.custom <- matrix(
c(0, 1, 1, 2, 1, 1,
1, 0, 1, 2, 1, 2,
1, 1, 0, 3, 1, 2,
2, 2, 3, 0, 3, 1,
1, 1, 1, 3, 0, 2,
1, 2, 2, 1, 2, 0),
nrow = 6, ncol = 6, byrow = TRUE)
## Computing the OM dissimilarities
mvaddist <- seqdist(mvadseq, method = "OM", indel = 1.5, sm = subm.custom)
wardCluster <- hclust(as.dist(mvaddist), method = "ward",
members = mvad$weight)
clust4 <- cutree(wardCluster, k = 4)
seqdplot(mvadseq, group = clust4, border = NA)
pamclust4 <- wcKMedoids(mvaddist, k = 4, weights = mvad$weight)
library(WeightedCluster)
pamclust4 <- wcKMedoids(mvaddist, k = 4, weights = mvad$weight)
mvad$pam4 <- factor(pamclust4$clustering, levels = c(66, 467,
607, 641), labels = c("Train-Empl", "School-Empl", "High Ed",
"Unempl")
)
mvad
mvad$pam4
tb<-xtabs(weight~test+pam4,data=mvad)
library(vegan)
worsq <- wcmdscale(mvaddist, w = mvad$weight, k = 2)
library(isotone)
mvad$test <- rep(-1, nrow(mvad))
for (clust in unique(pamclust4$clustering)) {
cond <- pamclust4$clustering == clust
values <- worsq[cond, 2]
mvad$test[cond] <- values > weighted.median(values,
w = mvad$weight[cond])
}
mvad$test <- factor(mvad$test, levels = 0:1, labels = c("non-test",
"test"))
tb<-xtabs(weight~test+pam4,data=mvad)
tb
chisq.test(tb)
?dissassoc
library(nhanes)
installed.packages(mice)
install.packages(mice)
install.packages("mice")
library(mice)
brandsma
?brandsma
install.packages("readstata13")
install.packages(c("fpc", "RColorBrewer", "TraMineR", "WeightedCluster"))
load("long_work_ed.Rda")
setwd("C:/Users/kemery/switchdrive/Multichannel sequence analysis")
setwd("~/switchdrive/Multichannel sequence analysis")
load(resultsMSA)
load("resultsMSA.Rda")
20600/200
2400/150
805/115
126*30
24750+805
25555-3780
21000/250
2100/140
99*30
21000-870
15281-11081-1570-500
113.7/25.5
4.458824*15.5
2294+1976+4607+7800
1570+480+231.8+1807+902+700+900+382+50
22677-7022
2510+2118+6406
(2510+2118+6406)-(2314+1976+4657)
# Un package R est un ensemble de fonctionnalites supplementaires qui
# peuvent etre chargees a la demande dans R.
# Exemple: le package "foreign"
#
# Il y a 2 etapes pour pouvoir les utiliser:
# 1. Installer le package sur le disque dur de l'ordinateur
#    (a faire une seule fois)
install.packages("foreign")
install.packages("Rtools")
library("Rtools")
install.packages("Rtools")
# Un package R est un ensemble de fonctionnalites supplementaires qui
# peuvent etre chargees a la demande dans R.
# Exemple: le package "foreign"
#
# Il y a 2 etapes pour pouvoir les utiliser:
# 1. Installer le package sur le disque dur de l'ordinateur
#    (a faire une seule fois)
install.packages("foreign")
# 2. Charger le package en memoire
#    (a faire a chaque nouvelle session de R)
library(foreign)
# La fonction "help()" permet d'obtenir de l'aide sur une autre fonction:
help(read.spss)
Data <- read.spss("ISSP_2017.sav", use.value.labels = TRUE,
use.missings = TRUE, to.data.frame = TRUE)
1133+250
1053+250
883+250
894+250
918+250
768+250
800+250
load("cleanedDataset.R")
library(foreign)
load("cleanedDataset.R")
W18 <- read.spss("COHORT18_P_USER.sav", use.value.labels = TRUE,
use.missings = FALSE, to.data.frame = TRUE)
W18 <- W18[W18$IDPERS%in%Data$IDPERS,]
D <- Data
rownames(D) <- 1:(dim(D)[1])
25799,15-23268,85
25799.15-23268.85
23268.85-19892.90
23268.85-19892.90-279.9*3
setwd("C:/Users/Kevin/Documents")
Sys.which("make")
install.packages("devtools")
install.packages("jsonlite", type = "source")
install.packages("devtools")
library(devtools)
install_version("mvnmle",version="0.1.11",repos="https://cran.r-project.org/src/contrib/Archive/mvnmle/mvnmle_0.1-11.tar.gz")
packageur1 <- "https://cran.r-project.org/src/contrib/Archive/mvnmle/mvnmle_0.1-11.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
install.packages("https://cran.r-project.org/src/contrib/Archive/mvnmle/mvnmle_0.1-11.tar.gz", repos=NULL, type="source")
library(mvnmle)
q()
library(BaylorEdPsych)
LittleMCAR()
LittleMCAR
library(mvnmle)
mletest
mletest()
mlest
reticulate::repl_python()
import pandas
yes
import pandas
import pandas as pd
import pandas as pd
reticulate::repl_python()
import pandas as pd
pip install numpy pandas matplotlib
pip install numpy pandas matplotlib
import numpy
py_install("pandas")
library(reticulate)
quit
library("foreign")
library("reticulate")
py_install("pandas")
reticulate::repl_python()
import pandas
number=input("Entrez un nombre:")
3
number=3
Ordered1=OrderedDico(bonjour)
class OrderedDico:
""" We create an ordered dictionary
"""
def __init__(self,dico={},**donnees):
self._cles=[]
self._valeurs=[]
if type(dico) not in [dict,OrderedDico]:
raise TypeError("Salut")
bonjour=[]
Ordered1=OrderedDico(bonjour)
"Salut")
class OrderedDico:
""" We create an ordered dictionary
"""
def __init__(self,dico={},**donnees):
self._cles=[]
self._valeurs=[]
if type(dico) not in [dict,OrderedDico]:
raise TypeError(\
"Salut")
bonjour=[]
Ordered1=OrderedDico(bonjour)
class DictionnaireOrdonne:
"""Notre dictionnaire ordonné. L'ordre des données est maintenu
et il peut donc, contrairement aux dictionnaires usuels, être trié
ou voir l'ordre de ses données inversées"""
def __init__(self, base={}, **donnees):
"""Constructeur de notre objet. Il peut ne prendre aucun paramètre
(dans ce cas, le dictionnaire sera vide) ou construire un
dictionnaire remplis grâce :
-   au dictionnaire 'base' passé en premier paramètre ;
-   aux valeurs que l'on retrouve dans 'donnees'."""
self._cles = [] # Liste contenant nos clés
self._valeurs = [] # Liste contenant les valeurs correspondant à nos clés
# On vérifie que 'base' est un dictionnaire exploitable
if type(base) not in (dict, DictionnaireOrdonne):
raise TypeError( \
"le type attendu est un dictionnaire (usuel ou ordonne)")
# On récupère les données de 'base'
for cle in base:
self[cle] = base[cle]
# On récupère les données de 'donnees'
for cle in donnees:
self[cle] = donnees[cle]
def __repr__(self):
"""Représentation de notre objet. C'est cette chaîne qui sera affichée
quand on saisit directement le dictionnaire dans l'interpréteur, ou en
utilisant la fonction 'repr'"""
chaine = "{"
premier_passage = True
for cle, valeur in self.items():
if not premier_passage:
chaine += ", " # On ajoute la virgule comme séparateur
else:
premier_passage = False
chaine += repr(cle) + ": " + repr(valeur)
chaine += "}"
return chaine
def __str__(self):
"""Fonction appelée quand on souhaite afficher le dictionnaire grâce
à la fonction 'print' ou le convertir en chaîne grâce au constructeur
'str'. On redirige sur __repr__"""
return repr(self)
def __len__(self):
"""Renvoie la taille du dictionnaire"""
return len(self._cles)
def __contains__(self, cle):
"""Renvoie True si la clé est dans la liste des clés, False sinon"""
return cle in self._cles
def __getitem__(self, cle):
"""Renvoie la valeur correspondant à la clé si elle existe, lève
une exception KeyError sinon"""
if cle not in self._cles:
raise KeyError( \
"La clé {0} ne se trouve pas dans le dictionnaire".format( \
cle))
else:
indice = self._cles.index(cle)
return self._valeurs[indice]
def __setitem__(self, cle, valeur):
"""Méthode spéciale appelée quand on cherche à modifier une clé
présente dans le dictionnaire. Si la clé n'est pas présente, on l'ajoute
à la fin du dictionnaire"""
if cle in self._cles:
indice = self._cles.index(cle)
self._valeurs[indice] = valeur
else:
self._cles.append(cle)
self._valeurs.append(valeur)
def __delitem__(self, cle):
"""Méthode appelée quand on souhaite supprimer une clé"""
if cle not in self._cles:
raise KeyError( \
"La clé {0} ne se trouve pas dans le dictionnaire".format( \
cle))
else:
indice = self._cles.index(cle)
del self._cles[indice]
del self._valeurs[indice]
def __iter__(self):
"""Méthode de parcours de l'objet. On renvoie l'itérateur des clés"""
return iter(self._cles)
def __add__(self, autre_objet):
"""On renvoie un nouveau dictionnaire contenant les deux
dictionnaires mis bout à bout (d'abord self puis autre_objet)"""
if type(autre_objet) is type(self):
raise TypeError( \
"Impossible de concaténer {0} et {1}".format( \
type(self), type(autre_objet)))
else:
nouveau = DictionnaireOrdonne()
# On commence par copier self dans le dictionnaire
for cle, valeur in self.items():
nouveau[cle] = valeur
# On copie ensuite autre_objet
for cle, valeur in autre_objet.items():
nouveau[cle] = valeur
return nouveau
def items(self):
"""Renvoie un générateur contenant les couples (cle, valeur)"""
for i, cle in enumerate(self._cles):
valeur = self._valeurs[i]
yield (cle, valeur)
def keys(self):
"""Cette méthode renvoie la liste des clés"""
return list(self._cles)
def values(self):
"""Cette méthode renvoie la liste des valeurs"""
return list(self._valeurs)
def reverse(self):
"""Inversion du dictionnaire"""
# On crée deux listes vides qui contiendront le nouvel ordre des clés
# et valeurs
cles = []
valeurs = []
for cle, valeur in self.items():
# On ajoute les clés et valeurs au début de la liste
cles.insert(0, cle)
valeurs.insert(0, valeur)
# On met ensuite à jour nos listes
self._cles = cles
self._valeurs = valeurs
def sort(self):
"""Méthode permettant de trier le dictionnaire en fonction de ses clés"""
# On trie les clés
cles_triees = sorted(self._cles)
# On crée une liste de valeurs, encore vide
valeurs = []
# On parcourt ensuite la liste des clés triées
for cle in cles_triees:
valeur = self[cle]
valeurs.append(valeur)
# Enfin, on met à jour notre liste de clés et de valeurs
self._cles = cles_triees
self._valeurs = valeurs
Dico1 = DictionnaireOrdonne(pommes=1, bananes=2)
class DictionnaireOrdonne:
"""Notre dictionnaire ordonné. L'ordre des données est maintenu
et il peut donc, contrairement aux dictionnaires usuels, être trié
ou voir l'ordre de ses données inversées"""
def __init__(self, base={}, **donnees):
"""Constructeur de notre objet. Il peut ne prendre aucun paramètre
(dans ce cas, le dictionnaire sera vide) ou construire un
dictionnaire remplis grâce :
-   au dictionnaire 'base' passé en premier paramètre ;
-   aux valeurs que l'on retrouve dans 'donnees'."""
self._cles = [] # Liste contenant nos clés
self._valeurs = [] # Liste contenant les valeurs correspondant à nos clés
# On vérifie que 'base' est un dictionnaire exploitable
if type(base) not in (dict, DictionnaireOrdonne):
raise TypeError( \
"le type attendu est un dictionnaire (usuel ou ordonne)")
# On récupère les données de 'base'
for cle in base:
self[cle] = base[cle]
# On récupère les données de 'donnees'
for cle in donnees:
self[cle] = donnees[cle]
def __repr__(self):
"""Représentation de notre objet. C'est cette chaîne qui sera affichée
quand on saisit directement le dictionnaire dans l'interpréteur, ou en
utilisant la fonction 'repr'"""
chaine = "{"
premier_passage = True
for cle, valeur in self.items():
if not premier_passage:
chaine += ", " # On ajoute la virgule comme séparateur
else:
premier_passage = False
chaine += repr(cle) + ": " + repr(valeur)
chaine += "}"
return chaine
def __str__(self):
"""Fonction appelée quand on souhaite afficher le dictionnaire grâce
à la fonction 'print' ou le convertir en chaîne grâce au constructeur
'str'. On redirige sur __repr__"""
return repr(self)
def __len__(self):
"""Renvoie la taille du dictionnaire"""
return len(self._cles)
def __contains__(self, cle):
"""Renvoie True si la clé est dans la liste des clés, False sinon"""
return cle in self._cles
def __getitem__(self, cle):
"""Renvoie la valeur correspondant à la clé si elle existe, lève
une exception KeyError sinon"""
if cle not in self._cles:
raise KeyError( \
"La clé {0} ne se trouve pas dans le dictionnaire".format( \
cle))
else:
indice = self._cles.index(cle)
return self._valeurs[indice]
def __setitem__(self, cle, valeur):
"""Méthode spéciale appelée quand on cherche à modifier une clé
présente dans le dictionnaire. Si la clé n'est pas présente, on l'ajoute
à la fin du dictionnaire"""
if cle in self._cles:
indice = self._cles.index(cle)
self._valeurs[indice] = valeur
else:
self._cles.append(cle)
self._valeurs.append(valeur)
def __delitem__(self, cle):
"""Méthode appelée quand on souhaite supprimer une clé"""
if cle not in self._cles:
raise KeyError( \
"La clé {0} ne se trouve pas dans le dictionnaire".format( \
cle))
else:
indice = self._cles.index(cle)
del self._cles[indice]
del self._valeurs[indice]
def __iter__(self):
"""Méthode de parcours de l'objet. On renvoie l'itérateur des clés"""
return iter(self._cles)
def __add__(self, autre_objet):
"""On renvoie un nouveau dictionnaire contenant les deux
dictionnaires mis bout à bout (d'abord self puis autre_objet)"""
if type(autre_objet) is type(self):
raise TypeError( \
"Impossible de concaténer {0} et {1}".format( \
type(self), type(autre_objet)))
else:
nouveau = DictionnaireOrdonne()
# On commence par copier self dans le dictionnaire
for cle, valeur in self.items():
nouveau[cle] = valeur
# On copie ensuite autre_objet
for cle, valeur in autre_objet.items():
nouveau[cle] = valeur
return nouveau
def items(self):
"""Renvoie un générateur contenant les couples (cle, valeur)"""
for i, cle in enumerate(self._cles):
valeur = self._valeurs[i]
yield (cle, valeur)
def keys(self):
"""Cette méthode renvoie la liste des clés"""
return list(self._cles)
def values(self):
"""Cette méthode renvoie la liste des valeurs"""
return list(self._valeurs)
def reverse(self):
"""Inversion du dictionnaire"""
# On crée deux listes vides qui contiendront le nouvel ordre des clés
# et valeurs
cles = []
valeurs = []
for cle, valeur in self.items():
# On ajoute les clés et valeurs au début de la liste
cles.insert(0, cle)
valeurs.insert(0, valeur)
# On met ensuite à jour nos listes
self._cles = cles
self._valeurs = valeurs
def sort(self):
"""Méthode permettant de trier le dictionnaire en fonction de ses clés"""
# On trie les clés
cles_triees = sorted(self._cles)
# On crée une liste de valeurs, encore vide
valeurs = []
# On parcourt ensuite la liste des clés triées
for cle in cles_triees:
valeur = self[cle]
valeurs.append(valeur)
# Enfin, on met à jour notre liste de clés et de valeurs
self._cles = cles_triees
self._valeurs = valeurs
Dico1 = DictionnaireOrdonne(pommes=1, bananes=2)
print(Dico1)
3/40
7/40
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
remove.packages("TraMineR", lib="~/R/win-library/4.0")
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
remove.packages("stringr", lib="~/R/win-library/4.0")
remove.packages("mlogit", lib="~/R/win-library/4.0")
remove.packages("mlbench", lib="~/R/win-library/4.0")
remove.packages("swfscMisc", lib="~/R/win-library/4.0")
remove.packages("plyr", lib="~/R/win-library/4.0")
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
remove.packages("rlang", lib="~/R/win-library/4.0")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.at.r-project.org"), dependencies = T)
?install.packages
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "https://cloud.r-project.org"), dependencies = T)
install.packages("rlang")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.rstudio.com"), dependencies = T)
remove.packages("rlang", lib="~/R/win-library/4.0")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.rstudio.com"), dependencies = T)
install.packages("rlang")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.rstudio.com/bin/windows/contrib"), dependencies = T)
remove.packages("rlang", lib="~/R/win-library/4.0")
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.rstudio.com/bin/windows/contrib"), dependencies = T)
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.rstudio.com/bin/windows/contrib"))
install.packages("seqimpute", repos = c("http://R-Forge.R-project.org", "http://cran.r-project.org"))
install.packages("rlang", repos = c( "http://cran.r-project.org"))
install.packages("seqimpute", repos = c( "http://cran.rstudio.com/bin/windows/contrib","http://R-Forge.R-project.org")
)
setwd("~/seqimpute/pkg")
document()
library(devtools)
document()
install.packages("seqimpute", repos="http://R-Forge.R-project.org")
install.packages("seqimpute", repos = "http://R-Forge.R-project.org")
