}
ODCharAndDashes <- apply(OD,1,CharAndDashes)
# 3.1 Number of listed impossible transitions -------------------------------------------------------------------------------------------------------
# Identifying the patterns of the impossible transitions in each line of OD
countImpTrans <- function(ODCharAndDashes) {
str_count(ODCharAndDashes,pattern=impTrans)
}
numbOfImpTransByRow <- sapply(ODCharAndDashes,countImpTrans)
if(length(impTrans)>1) {
numbOfImpTrans <- rowSums(numbOfImpTransByRow)
} else {
numbOfImpTrans <- sum(numbOfImpTransByRow)
}
# Interrupting the program in case no impossible transitions among impTrans have
# been found
if (sum(numbOfImpTrans) == 0) {
stop(" /!\\ Warning, no impossible transitions have been found. Your input vector impTrans doesn't contain any transitions present in your dataset.")
}
numbOfImpTrans
numbOfImpTransByRow
ODCharAndDashes
?str_count
lookin<-c("babababa", "bellow", "ra;baba")
searchfor<-"aba"
paste0("(?=",searchfor,")")
countImpTrans <- function(ODCharAndDashes) {
str_count(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
}
numbOfImpTransByRow <- sapply(ODCharAndDashes,countImpTrans)
countImpTrans()
numbOfImpTransByRow
if(length(impTrans)>1) {
numbOfImpTrans <- rowSums(numbOfImpTransByRow)
} else {
numbOfImpTrans <- sum(numbOfImpTransByRow)
}
# Interrupting the program in case no impossible transitions among impTrans have
# been found
if (sum(numbOfImpTrans) == 0) {
stop(" /!\\ Warning, no impossible transitions have been found. Your input vector impTrans doesn't contain any transitions present in your dataset.")
}
# 3.2 Location of the listed impossible transitions -------------------------------------------------------------------------------------------------
locOfImpTrans <- function(ODCharAndDashes) {
str_locate_all(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
}
impTrans
impTrans <- c("yes->yes","yes->no")
# Naming the number of rows and columns of OD
nr <- nrow(OD)
nc <- ncol(OD)
# test
# 1. Initial tests on parameters --------------------------------------------------------------------------------------------------------------------
# 1.1 Testing the class of the variables of the original dataset OD ---------------------------------------------------------------------------------
ODClass <- class(OD[1,1])
if ( (ODClass != "factor") & (ODClass != "numeric") ) {
stop("/!\\ The class of the variables contained in your original dataset
should be either 'factor' or 'numeric'")
}
# 1.2 Testing effectively exactly k possible categories of the multinomial variable -----------------------------------------------------------------
if (class(OD[1,1]) == "numeric") {
for (i in 1:nr) {
for (j in 1:nc) {
if ( is.na(OD[i,j])==FALSE & (OD[i,j]<=0 | OD[i,j]>k) ) {
stop("/!\\ Your dataset doesn't contain the right number of k categories of the multinomial variable")
} else {
next
}
}
}
} else { # Meaning that our values are of type "factor"
for (i in 1:nr) {
for (j in 1:nc) {
if (length(levels(OD[i,j])) != k) {
stop("/!\\ Your dataset doesn't contain the right number of k categories of the multinomial variable")
} else {
next
}
}
}
}
# 1.3 Indicating the existence of entire rows of OD filled only with NAs to the user ----------------------------------------------------------------
i <- 1
numbOfNAFilledLines <- 0
while (i <= nrow(OD)) {
if (all(is.na(OD[i,]))) {
OD <- OD[-i,]
numbOfNAFilledLines <- numbOfNAFilledLines + 1
warning(paste("/!\\ Row number",i,"of OD consists only of NAs."),sep='')
}
i <- i+1
}
if (numbOfNAFilledLines == 1) {
warning(paste("Your data matrix contains 1 row filled solely with NAs. This row won't be included into the next statistics about NAs."),sep='')
}
if (numbOfNAFilledLines > 1) {
warning(paste("Your data matrix contains",numbOfNAFilledLines,"rows filled solely with NAs."),sep='',"\n",
"  These rows have been removed and thus haven't been included in","\n",
"  the analysis of the impossible transitions among your dataset.")
}
# Updating the number of rows in OD
nr <- nrow(OD)
# 1.4 Test on input parameter impTrans -----------------------------------------
for (i in 1:length(impTrans)) {
if (!str_detect(impTrans[i],"->")) {
stop("/!\\ Warning, you should construct your impossible transition(s) vector impTrans with little arrows as follow: impTrans <- c('...->...', '...->...', etc.).")
}
# Testing if we are effectively analyzing a transition or not
locDash <- str_locate(impTrans[i],"-")
firstState <- substr(impTrans[i],1,locDash-1)
locSpike <- str_locate(impTrans[i],">")
secondState <- substr(impTrans[i],locSpike+1,nchar(impTrans[1]))
# if (firstState==secondState) {
# stop("/!\\ You have typed in two same states (two times '",firstState,"') on both sides of the arrow. This doesn't correspond to a transition.")
# }
}
# 2. Finding number of gaps -------------------------------------------------------------------------------------------------------------------------
# 2.1 Number of initial gaps ------------------------------------------------------------------------------------------------------------------------
#
# Creation of matrix ORDER
ORDER <- matrix(0,nr,nc) # initialization of matrix ORDER with 0 everywhere
SEL <- is.na(OD)==TRUE   # creation of matrix SEL, constituted of TRUE where there is MD in OD and of FALSE everywhere else
ORDER[SEL] <- 1          # setting some 1 in ORDER at the location where in SEL we have some TRUE
# Creation of vector InitGapSize (i.e. a vector containing the size of the initial gaps of each line)
InitGapSize <- vector()
for (i in 1:nr) {
if (ORDER[i,1]==0) {
InitGapSize[i] <- 0
} else {
InitGapSize[i] <- 1
for (j in 2:nc) {
if (ORDER[i,j]==1) {
InitGapSize[i] <- InitGapSize[i] + 1
} else {
break
}
}
}
}
MaxInitGapSize <- max(InitGapSize)
# Number of initial gaps
numbOfInitGaps <- length(InitGapSize[InitGapSize!=0])
# Creation of matrix ORDERI
ORDERI <- matrix(0,nr,nc)
for (i in 1:nr) {
if (InitGapSize[i]!=0) {
ORDERI[i,1:InitGapSize[i]] <- c(MaxInitGapSize:(MaxInitGapSize+1-InitGapSize[i]))
} else {
next
}
}
# Replacing each value of ORDERI greater than '0' by '1'
ORDERI[ORDERI > 0] <- 1
# 2.2 Number of terminal gaps -----------------------------------------------------------------------------------------------------------------------
# Creation of vector TermGapSize (i.e. a vector containing the size of the terminal gaps of each line)
TermGapSize <- vector()
for (i in 1:nr) {
if (ORDER[i,nc]==0) {
TermGapSize[i] <- 0
} else {
TermGapSize[i] <- 1
for (j in (nc-1):1) {
if (ORDER[i,j]==1) {
TermGapSize[i] <- TermGapSize[i] + 1
} else {
break
}
}
}
}
MaxTermGapSize <- max(TermGapSize)
# Number of terminal gaps
numbOfTermGaps <- length(TermGapSize[TermGapSize!=0])
# Creation of matrix ORDERT
ORDERT <- matrix(0,nr,nc)
for (i in 1:nr) {
if (TermGapSize[i]!=0) {
ORDERT[i,(nc-TermGapSize[i]+1):nc] <- c((MaxTermGapSize+1-TermGapSize[i]):MaxTermGapSize)
} else {
next
}
}
# Replacing each value of ORDERT greater than '0' by '1'
ORDERT[ORDERT > 0] <- 1
# 2.3 Number of internal gaps -----------------------------------------------------------------------------------------------------------------------
# /!\ Final version of the matrix ORDER that we use through point 3.1 to 3.3 of the program
ORDER <- ORDER - ORDERI - ORDERT
# Number of Internal Gaps
# Transforming ORDER in a single row vector
ORDERVect <- as.vector(t(ORDER))
# Transforming this single row vector into class character
ORDERVectChar <- paste(ORDERVect,collapse="")
# Identifying the patterns "0 1" (this is the signature look of an internal gap
# (it always indicates the beginning of an internal gap!))
numbOfInternGaps <- str_count(ORDERVectChar,pattern="01")
# Warning message returning the number of gaps of each type included in OD
if ( (numbOfInitGaps > 0) | (numbOfTermGaps > 0) | (numbOfInternGaps > 0) ) {
warning("/!\\ We have detected ",numbOfInitGaps," initial gap(s), ",numbOfTermGaps," terminal gap(s)","\n",
"    and ",numbOfInternGaps," internal gap(s) in your dataset.","\n",
"    Be aware that these gaps may hide other impossible transitions!")
}
# 3. Spotting impossible transitions ----------------------------------------------------------------------------------------------------------------
## Setup
#
# Transforming every line of OD into class character and adding a dash inbetween
# every state
dashes <- replicate(nc,"->")
CharAndDashes <- function(OD) {
mytestChar <- paste(as.vector(rbind(OD,dashes)),collapse="")
}
ODCharAndDashes <- apply(OD,1,CharAndDashes)
# 3.1 Number of listed impossible transitions -------------------------------------------------------------------------------------------------------
# Identifying the patterns of the impossible transitions in each line of OD
countImpTrans <- function(ODCharAndDashes) {
str_count(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
}
numbOfImpTransByRow <- sapply(ODCharAndDashes,countImpTrans)
if(length(impTrans)>1) {
numbOfImpTrans <- rowSums(numbOfImpTransByRow)
} else {
numbOfImpTrans <- sum(numbOfImpTransByRow)
}
numbOfImpTrans
numbOfImpTransByRow
impTrans <- c("yes->yes","no->no")
# 2. Finding number of gaps -------------------------------------------------------------------------------------------------------------------------
# 2.1 Number of initial gaps ------------------------------------------------------------------------------------------------------------------------
#
# Creation of matrix ORDER
ORDER <- matrix(0,nr,nc) # initialization of matrix ORDER with 0 everywhere
SEL <- is.na(OD)==TRUE   # creation of matrix SEL, constituted of TRUE where there is MD in OD and of FALSE everywhere else
ORDER[SEL] <- 1          # setting some 1 in ORDER at the location where in SEL we have some TRUE
# Creation of vector InitGapSize (i.e. a vector containing the size of the initial gaps of each line)
InitGapSize <- vector()
for (i in 1:nr) {
if (ORDER[i,1]==0) {
InitGapSize[i] <- 0
} else {
InitGapSize[i] <- 1
for (j in 2:nc) {
if (ORDER[i,j]==1) {
InitGapSize[i] <- InitGapSize[i] + 1
} else {
break
}
}
}
}
MaxInitGapSize <- max(InitGapSize)
# Number of initial gaps
numbOfInitGaps <- length(InitGapSize[InitGapSize!=0])
# Creation of matrix ORDERI
ORDERI <- matrix(0,nr,nc)
for (i in 1:nr) {
if (InitGapSize[i]!=0) {
ORDERI[i,1:InitGapSize[i]] <- c(MaxInitGapSize:(MaxInitGapSize+1-InitGapSize[i]))
} else {
next
}
}
# Replacing each value of ORDERI greater than '0' by '1'
ORDERI[ORDERI > 0] <- 1
# 2.2 Number of terminal gaps -----------------------------------------------------------------------------------------------------------------------
# Creation of vector TermGapSize (i.e. a vector containing the size of the terminal gaps of each line)
TermGapSize <- vector()
for (i in 1:nr) {
if (ORDER[i,nc]==0) {
TermGapSize[i] <- 0
} else {
TermGapSize[i] <- 1
for (j in (nc-1):1) {
if (ORDER[i,j]==1) {
TermGapSize[i] <- TermGapSize[i] + 1
} else {
break
}
}
}
}
MaxTermGapSize <- max(TermGapSize)
# Number of terminal gaps
numbOfTermGaps <- length(TermGapSize[TermGapSize!=0])
# Creation of matrix ORDERT
ORDERT <- matrix(0,nr,nc)
for (i in 1:nr) {
if (TermGapSize[i]!=0) {
ORDERT[i,(nc-TermGapSize[i]+1):nc] <- c((MaxTermGapSize+1-TermGapSize[i]):MaxTermGapSize)
} else {
next
}
}
# Replacing each value of ORDERT greater than '0' by '1'
ORDERT[ORDERT > 0] <- 1
# 2.3 Number of internal gaps -----------------------------------------------------------------------------------------------------------------------
# /!\ Final version of the matrix ORDER that we use through point 3.1 to 3.3 of the program
ORDER <- ORDER - ORDERI - ORDERT
# Number of Internal Gaps
# Transforming ORDER in a single row vector
ORDERVect <- as.vector(t(ORDER))
# Transforming this single row vector into class character
ORDERVectChar <- paste(ORDERVect,collapse="")
# Identifying the patterns "0 1" (this is the signature look of an internal gap
# (it always indicates the beginning of an internal gap!))
numbOfInternGaps <- str_count(ORDERVectChar,pattern="01")
# Warning message returning the number of gaps of each type included in OD
if ( (numbOfInitGaps > 0) | (numbOfTermGaps > 0) | (numbOfInternGaps > 0) ) {
warning("/!\\ We have detected ",numbOfInitGaps," initial gap(s), ",numbOfTermGaps," terminal gap(s)","\n",
"    and ",numbOfInternGaps," internal gap(s) in your dataset.","\n",
"    Be aware that these gaps may hide other impossible transitions!")
}
# 3. Spotting impossible transitions ----------------------------------------------------------------------------------------------------------------
## Setup
#
# Transforming every line of OD into class character and adding a dash inbetween
# every state
dashes <- replicate(nc,"->")
CharAndDashes <- function(OD) {
mytestChar <- paste(as.vector(rbind(OD,dashes)),collapse="")
}
ODCharAndDashes <- apply(OD,1,CharAndDashes)
# 3.1 Number of listed impossible transitions -------------------------------------------------------------------------------------------------------
# Identifying the patterns of the impossible transitions in each line of OD
countImpTrans <- function(ODCharAndDashes) {
str_count(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
}
numbOfImpTransByRow <- sapply(ODCharAndDashes,countImpTrans)
if(length(impTrans)>1) {
numbOfImpTrans <- rowSums(numbOfImpTransByRow)
} else {
numbOfImpTrans <- sum(numbOfImpTransByRow)
}
numbOfImpTransByRow
# 3.2 Location of the listed impossible transitions -------------------------------------------------------------------------------------------------
locOfImpTrans <- function(ODCharAndDashes) {
str_locate_all(ODCharAndDashes,paste0("(?=",impTrans,")"))
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
}
startLocList
if (length(impTrans)>1) {
startLocMat <- matrix(NA,nrow=length(impTrans),ncol=nrow(OD))
for (i in 1:length(impTrans)) {
for (j in 1:nrow(OD)) {
tempMat <- as.data.frame(startLocList[i,j])
if (nrow(tempMat) > 0) {
if (nrow(tempMat) > 1) {
tempMat <- t(tempMat)
tempMat <- apply(tempMat[,1:nrow(tempMat)], 1, paste , collapse = " " )
}
startLocMat[i,j] <- as.matrix(tempMat[1])
}
}
}
} else {
# In case length(impTrans) == 1 (i.e. we are looking for only one single
# impossible transition)
startLocMat <- matrix(NA,nrow=1,ncol=nrow(OD))
for (j in 1:nrow(OD)) {
tempMat <- as.data.frame(startLocList[j])
if (nrow(tempMat) > 0) {
if (nrow(tempMat) > 1) {
tempMat <- t(tempMat)
tempMat <- apply(tempMat[,1:nrow(tempMat)], 1, paste , collapse = " " )
}
startLocMat[j] <- as.matrix(tempMat[1])
}
}
}
startLocMat
# The rows of startLocMat indicate the type of impossible transition, its columns
# indicate the row coordinate in OD of the impossible transition and the positive
# values inside startLocMat inform about the column coordinate in OD of the
# impossible transition
#
# Generating the matrix informing about the row location in OD and the matrix
# informing about the column location in OD
rowMat<- matrix(NA,nrow(startLocMat),ncol(startLocMat))
colMat <- rowMat
for (j in 1:ncol(startLocMat)) {
goTo <- which(!is.na(startLocMat[,j]))
if (sum(goTo) > 0) {
for (h in 1:length(goTo)) {
# Columns of startLocMat indicate the row index in OD
rowMat[goTo[h],j] <- j
# Positive values in startLocMat indicate the column index in OD
colMat[goTo[h],j] <- startLocMat[goTo[h],j]
}
}
}
rowMat
colMat
# 3.2 Location of the listed impossible transitions -------------------------------------------------------------------------------------------------
locOfImpTrans <- function(ODCharAndDashes) {
str_locate_all(ODCharAndDashes,paste0("(?=",impTrans,")"))
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
}
startLocList
ODCharAndDashes
locOfImpTrans <- function(ODCharAndDashes) {
str_locate_all(ODCharAndDashes,paste0(impTrans))
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
}
startLocList
?str_locate_all
fruit <- c("apple", "banana", "pear", "pineapple")
str_locate(fruit, "$")
str_locate(fruit, "a")
fruit <- c("apple", "banana", "pear", "pineapple")
str_locate(fruit, "$")
str_locate_all(fruit, "a")
sapply(ODCharAndDashes,locOfImpTrans)
apply(ODCharAndDashes,locOfImpTrans)
startLocList <- str_locate_all(ODCharAndDashes,pattern=paste0(impTrans))
startLocList <- str_locate_all(ODCharAndDashes,pattern=paste0(impTrans[1]))
startLocList
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans[1])
startLocList
numbOfImpTransByRow
startLocList <- str_locate_all(ODCharAndDashes,pattern=paste0(impTrans[1]))
startLocList
locOfImpTrans <- function(ODCharAndDashes) {
as.integer(gregexpr(paste0("(?=",impTrans,")"), ODCharAndDashes, perl = TRUE)[[1]])
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans[1])
}
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
sapply(ODCharAndDashes,locOfImpTrans)
ODCharAndDashes
stringr::str_locate_all(ODCharAndDashes[3], "(?=yes->yes)")[[1]][,1]
ODCharAndDashes[3]
stringr::str_locate_all(ODCharAndDashes[4], "(?=yes->yes)")[[1]][,1]
stringr::str_locate_all(ODCharAndDashes[4], "(?=impTrans[1])")[[1]][,1]
impTrans[1]
a<-"(?=yes->yes)"
a
b<-"(?=impTrans[1])"
b
paste0("(?=",impTrans,")")
str_locate_all(ODCharAndDashes,pattern=impTrans)
ODCharAndDashes
impTrans
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
# 3.1 Number of listed impossible transitions -------------------------------------------------------------------------------------------------------
# Identifying the patterns of the impossible transitions in each line of OD
countImpTrans <- function(ODCharAndDashes) {
str_count(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
}
numbOfImpTransByRow <- sapply(ODCharAndDashes,countImpTrans)
if(length(impTrans)>1) {
numbOfImpTrans <- rowSums(numbOfImpTransByRow)
} else {
numbOfImpTrans <- sum(numbOfImpTransByRow)
}
# Interrupting the program in case no impossible transitions among impTrans have
# been found
if (sum(numbOfImpTrans) == 0) {
stop(" /!\\ Warning, no impossible transitions have been found. Your input vector impTrans doesn't contain any transitions present in your dataset.")
}
numbOfImpTrans
numbOfImpTransByRow
# 3.2 Location of the listed impossible transitions -------------------------------------------------------------------------------------------------
locOfImpTrans <- function(ODCharAndDashes) {
str_locate_all(ODCharAndDashes,pattern=pattern=paste0("(?=",impTrans,")"))
}
if (length(impTrans)>1) {
startLocList <- sapply(ODCharAndDashes,locOfImpTrans)[1:length(impTrans),]
} else {
startLocList <- str_locate_all(ODCharAndDashes,pattern=impTrans)
}
sapply(ODCharAndDashes,locOfImpTrans)
startLocList <- str_locate_all(ODCharAndDashes,pattern=paste0("(?=",impTrans,")"))
startLocList <- str_locate_all(ODCharAndDashes,pattern=paste0("(?=",impTrans[1],")"))
startLocList
x1 <- "11110001101"
gregexpr("(?=11)", x1, perl = TRUE)
"(?=11)"
str_locate_all(ODCharAndDashes,pattern=paste0("(?=",impTrans[1],")"))
gregexpr(ODCharAndDashes, impTrans[1], perl = TRUE)
impTrans[1]
gregexpr(ODCharAndDashes, paste0("?=",impTrans[1],")"), perl = TRUE)
gregexpr(ODCharAndDashes[1], paste0("?=",impTrans[1],")"), perl = TRUE)
gregexpr(ODCharAndDashes[2], paste0("?=",impTrans[1],")"), perl = TRUE)
gregexpr(ODCharAndDashes[3], paste0("?=",impTrans[1],")"), perl = TRUE)
gregexpr(ODCharAndDashes[4], paste0("?=",impTrans[1],")"), perl = TRUE)
as.integer(gregexpr(ODCharAndDashes[4], paste0("?=",impTrans[1],")"), perl = TRUE))
ODCharAndDashes[4]
paste0("?=",impTrans[1],")")
as.integer(gregexpr(ODCharAndDashes[4], paste0("(?=",impTrans[1],")"), perl = TRUE))
paste0("(?=",impTrans[1],")")
as.integer(gregexpr(ODCharAndDashes[4], "(?=yes->yes)", perl = TRUE))
gregexpr(ODCharAndDashes[4], "(?=yes->yes)", perl = TRUE)
gregexpr(ODCharAndDashes[4], "yes->yes", perl = TRUE)
gregexpr("(?=yes->yes)", ODCharAndDashes[4],perl = TRUE)
gregexpr("(?=yes->yes)", ODCharAndDashes,perl = TRUE)
